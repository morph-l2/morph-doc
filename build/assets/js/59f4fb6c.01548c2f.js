"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[3186],{5637:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var o=t(3274),i=t(2333);const r={title:"Transactions Life Cycle",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},s=void 0,a={id:"how-morph-works/general-protocol-design/transactions-life-cycle",title:"Transactions Life Cycle",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!",source:"@site/docs/how-morph-works/general-protocol-design/4-transactions-life-cycle.md",sourceDirName:"how-morph-works/general-protocol-design",slug:"/how-morph-works/general-protocol-design/transactions-life-cycle",permalink:"/docs/how-morph-works/general-protocol-design/transactions-life-cycle",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/how-morph-works/general-protocol-design/4-transactions-life-cycle.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Transactions Life Cycle",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},sidebar:"HowSidebar",previous:{title:"Communication between Morph and Ethereum",permalink:"/docs/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum"},next:{title:"Difference between Morph and Ethereum",permalink:"/docs/how-morph-works/general-protocol-design/difference-between-ethereum-and-morph"}},c={},l=[{value:"How does a L2 transaction processed on Morph",id:"how-does-a-l2-transaction-processed-on-morph",level:2},{value:"Morph Transaction Status",id:"morph-transaction-status",level:2},{value:"Processing\u200b",id:"processing",level:3},{value:"Confirmed\u200b",id:"confirmed",level:3},{value:"Safe",id:"safe",level:3},{value:"Finalized\u200b",id:"finalized",level:3}];function h(e){const n={a:"a",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"how-does-a-l2-transaction-processed-on-morph",children:"How does a L2 transaction processed on Morph"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Submit Transaction"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Users-initiated transactions are first sent to the l2 node's mempool, where they await selection and processing by a sequencer."}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:"Transaction Consensus"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Within the sequencer network, transactions undergo a consensus process. A selected sequencer proposes a block containing the transaction and then send the blocks to the consensus layer (consensus client)."}),"\n",(0,o.jsx)(n.p,{children:"Other sequencers then validate this block by executing this block, effectively verifying the transaction's legitimacy."}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:"Transaction Execution"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Once all the votes on the block is finalized, each sequencer & node will apply this block to update its local state."}),"\n",(0,o.jsxs)(n.ol,{start:"4",children:["\n",(0,o.jsx)(n.li,{children:"Transaction Batching"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"When batch point is reached, each sequencer will need to construct the batch with all the blocks consensued for the last epoch, the batch will go through consensus by requiring each sequencer to sign, all of the signature will be aggregated with BLS signature."}),"\n",(0,o.jsxs)(n.ol,{start:"5",children:["\n",(0,o.jsx)(n.li,{children:"Batch Sequencing"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The selected sequencer (",(0,o.jsx)(n.a,{href:"/docs/how-morph-works/general-protocol-design/rollup",children:"learn how it works"}),") will commit the batches to the Layer 1 Rollup contract for both verification and to ensure data availability."]}),"\n",(0,o.jsxs)(n.ol,{start:"6",children:["\n",(0,o.jsx)(n.li,{children:"Batch Verification"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["A batch (so do the transactions within the batch)will first go through the BLS signature verification by the rollup contract to confirm the L2 consensus results, and then a batch will go through a ",(0,o.jsx)(n.a,{href:"/docs/how-morph-works/responsive-validity-proof/why-rvp",children:"challenge period"})," to be marked as finalized, solidifying their status within the L1 and L2 state."]}),"\n",(0,o.jsx)(n.h2,{id:"morph-transaction-status",children:"Morph Transaction Status"}),"\n",(0,o.jsx)(n.h3,{id:"processing",children:"Processing\u200b"}),"\n",(0,o.jsx)(n.p,{children:"Once submitted, a transaction enters the consensus phase managed by sequencers and is placed into a block pre-execution."}),"\n",(0,o.jsx)(n.h3,{id:"confirmed",children:"Confirmed\u200b"}),"\n",(0,o.jsx)(n.p,{children:"Post-execution by the Sequencer, the transaction\u2019s updated state is local to L2. It is then batched and sent to L1, where it must undergo a challenge period before finalization."}),"\n",(0,o.jsx)(n.h3,{id:"safe",children:"Safe"}),"\n",(0,o.jsx)(n.p,{children:"The batch that contains the transaction is submiited to Layer 1 but not finalized yet."}),"\n",(0,o.jsx)(n.h3,{id:"finalized",children:"Finalized\u200b"}),"\n",(0,o.jsx)(n.p,{children:"A transaction is considered finalized after it survives the challenge period or is verified by a Zero-Knowledge Proof (ZK-Proof). Only then is it officially integrated into the final L1 and L2 state."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},2333:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(9474);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);