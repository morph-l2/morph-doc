"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[4766],{3877:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var n=o(3274),i=o(2333);const s={title:"Rollup",lang:"en-US",keywords:["morph","ethereum","rollup"],description:"Explain how rollup process works in Morph"},r=void 0,a={id:"how-morph-works/general-protocol-design/rollup",title:"Rollup",description:"Explain how rollup process works in Morph",source:"@site/docs/how-morph-works/general-protocol-design/1-rollup.md",sourceDirName:"how-morph-works/general-protocol-design",slug:"/how-morph-works/general-protocol-design/rollup",permalink:"/docs/how-morph-works/general-protocol-design/rollup",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/how-morph-works/general-protocol-design/1-rollup.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Rollup",lang:"en-US",keywords:["morph","ethereum","rollup"],description:"Explain how rollup process works in Morph"},sidebar:"HowSidebar",previous:{title:"How does RVP Applied in Morph",permalink:"/docs/how-morph-works/responsive-validity-proof/how-rvp-applied"},next:{title:"Communication between Morph and Ethereum",permalink:"/docs/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum"}},l={},c=[{value:"An overview of Morph Rollup Design:",id:"an-overview-of-morph-rollup-design",level:3},{value:"Constructing the Batch\u200b",id:"constructing-the-batch",level:2},{value:"Putting Multiple Batches into a Single Rollup Transaction\u200b",id:"putting-multiple-batches-into-a-single-rollup-transaction",level:2},{value:"Submitting Batch Data to the Rollup Contract\u200b",id:"submitting-batch-data-to-the-rollup-contract",level:2},{value:"Finalize the batches",id:"finalize-the-batches",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.admonition,{type:"info",children:[(0,n.jsx)(t.p,{children:'As the foundation of a Layer 2 project, the "Rollup" process refers to the method by which Layer 2 assembles L2 transactions and state into batches and subsequently submits them to L1, along with the L2 state.'}),(0,n.jsxs)(t.p,{children:["Within ",(0,n.jsx)(t.a,{href:"/docs/how-morph-works/morph-modular-design",children:"Morph's architecture"}),", this Rollup process is executed by the ",(0,n.jsx)(t.code,{children:"Batch Submitter"})," components."]})]}),"\n",(0,n.jsx)(t.h3,{id:"an-overview-of-morph-rollup-design",children:"An overview of Morph Rollup Design:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"rollup",src:o(1650).A+"",width:"1920",height:"1080"})}),"\n",(0,n.jsx)(t.h2,{id:"constructing-the-batch",children:"Constructing the Batch\u200b"}),"\n",(0,n.jsx)(t.p,{children:"The L2 Node within the sequencer generates L2 blocks based on consensus results and updates the local state of L2. The batch submitter must query the L2 node to retrieve the latest L2 blocks."}),"\n",(0,n.jsx)(t.p,{children:"The batch submitter then reconstructs L2 blocks, compiling:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Transactions: All transactions contained within the blocks."}),"\n",(0,n.jsx)(t.li,{children:"Blockinfo : Essential information from each block."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The batch submitter continues fetching and reconstructing blocks until it processes a block with a BLS signature, indicating the batch point has been reached. The reconstructed block da is used to construct a batch, which contains:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"lastBlocknumber : The number of the final block in the batch"}),"\n",(0,n.jsx)(t.li,{children:"Transactions : Encoded transactions within the batch."}),"\n",(0,n.jsx)(t.li,{children:"BlockWitness : Encoded blockinfos, utilized for zkProof"}),"\n",(0,n.jsx)(t.li,{children:"PreStateRoot : The stateRoot before the batch is applied."}),"\n",(0,n.jsx)(t.li,{children:"PostStateRoot : The stateRoot after the batch is applied."}),"\n",(0,n.jsx)(t.li,{children:"WithdrawalRoot : L2 withdrawal Merkle tree root."}),"\n",(0,n.jsx)(t.li,{children:"Signature : The batch\u2019s BLS signature."}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"Blockinfo (BlockWitness) is needed since Morph employs zk technology to prove the accuracy of submitted batch data. It serves as a witness in the Zero-Knowledge Proof."})}),"\n",(0,n.jsx)(t.h2,{id:"putting-multiple-batches-into-a-single-rollup-transaction",children:"Putting Multiple Batches into a Single Rollup Transaction\u200b"}),"\n",(0,n.jsx)(t.p,{children:"While it's standard for roll-up projects to include only one batch per L1 roll-up transaction, Morph optimizes by inserting as many batches as feasible into a single L1 transaction."}),"\n",(0,n.jsx)(t.p,{children:"This efficiency-driven approach significantly reduces overall costs, as the L1 fee is a predominant component of the transaction costs associated with the L2. By optimizing the utilization of available space, Morph achieves cost-effectiveness without compromising transaction integrity."}),"\n",(0,n.jsx)(t.h2,{id:"submitting-batch-data-to-the-rollup-contract",children:"Submitting Batch Data to the Rollup Contract\u200b"}),"\n",(0,n.jsx)(t.p,{children:"The batch submitter will eventually send an Ethereum transaction from its L1 account to Morph's main contract."}),"\n",(0,n.jsx)(t.p,{children:"The transaction's calldata contains the batch data."}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"Based on the development process of ERC-4337, future batch data will likely be incorporated into a new \u2018tree\u2019 structure to further decrease costs."})}),"\n",(0,n.jsx)(t.p,{children:"Once the transaction is submitted and confirmed on Ethereum, validator nodes can reconstruct and verify the validity of sequencers' submissions using the transactional data within the batch."}),"\n",(0,n.jsx)(t.h2,{id:"finalize-the-batches",children:"Finalize the batches"}),"\n",(0,n.jsxs)(t.p,{children:["If batches are valid according to Morph's ",(0,n.jsx)(t.a,{href:"/docs/how-morph-works/responsive-validity-proof/overview",children:"responsive validity proof"})," standards, all transactions within the batches will be finalized, including withdrawal transactions."]}),"\n",(0,n.jsx)(t.p,{children:"Consequently, withdrawal requests will be fulfilled, and the corresponding locked assets on Layer 1 will be released."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},1650:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/rollup-ec0a8c4e6fd4f059adc10a764554bb2d.png"},2333:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var n=o(9474);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);